<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>official music fan club</title>
		<style>
			body { margin: 0; background-color: black; }
			canvas { display: block; }
            .ytplayer { pointer-events: none; }
		</style>
	</head>
	<body>
        <script>
            onPlayerStateChange = function (event) {
                console.log(event);
            }
            onYouTubeIframeAPIReady = function () {
                console.log('ready');
                ytplayer = new YT.Player('ytplayer', {
                    events: {
                        'onStateChange': onPlayerStateChange
                    }
                });
            };
        </script>
		<script type="module">
            import * as THREE from 'https://threejs.org/build/three.module.js';
            import { CSS3DRenderer, CSS3DObject } from 'https://threejs.org/examples/jsm/renderers/CSS3DRenderer.js';
            import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
            import { OutlinePass } from 'https://threejs.org/examples/jsm/postprocessing/OutlinePass.js';
            import { AfterimagePass } from 'https://threejs.org/examples/jsm/postprocessing/AfterimagePass.js';

            let plane = null;
            let planeXRot = 0;
            let planeYRot = 0;
            let ytEmbed = null;
            let scene, CSSscene, camera, renderer, CSSrenderer, composer;

            // constants
            const playlistID = 'UU1YTajqhUd01VO-yr5bL08A';
            const videoWidthPx = 480;
            const videoHeightPx = 360;

            window.addEventListener( 'resize', onWindowResize, false );
            window.addEventListener( 'mousemove', onMouseMove, false );

            async function init() {

                scene = new THREE.Scene();
                CSSscene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set(0, 0, 1);

                renderer = new THREE.WebGLRenderer({alpha: true});
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.zIndex = -2;
                renderer.domElement.style.top = 0;
                
                CSSrenderer = new CSS3DRenderer();
                CSSrenderer.domElement.style.position = 'absolute';
                CSSrenderer.domElement.style.top = 0;
                CSSrenderer.domElement.appendChild(renderer.domElement);

                document.body.appendChild(CSSrenderer.domElement);

                composer = new EffectComposer( renderer );
                composer.addPass( new RenderPass( scene, camera ) );
                
                // build scene
                const geometry = new THREE.PlaneGeometry( 1, 1 );
                const material = new THREE.MeshBasicMaterial( {color: 0x000000, side: THREE.DoubleSide} );
                plane = new THREE.Mesh( geometry, material );
                scene.add( plane );
                
                // youtube embed
                const div = document.createElement( 'div' );
                div.style.width = `${videoWidthPx}px`;
                div.style.height = `${videoHeightPx}px`;
                div.style.backgroundColor = '#000';
                const iframe = document.createElement( 'iframe' );
                iframe.id = 'ytplayer';
                iframe.style.width = `${videoWidthPx}px`;
                iframe.style.height = `${videoHeightPx}px`;
                iframe.style.border = '0px';
                iframe.src = `https://youtube.com/embed/videoseries?list=${playlistID}&rel=0&controls=0&autoplay=1&enablejsapi=1&playsinline=1`;
                iframe.allow = 'accelerometer; autoplay; encrypted-media; gyroscope;';
                div.appendChild( iframe );
                ytEmbed = new CSS3DObject( div );
                ytEmbed.position.set(0, 0, 0);
                CSSscene.add( ytEmbed );

                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                
                // postprocessing effects
                const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera, [plane]);
                outlinePass.edgeStrength = 8;
                outlinePass.visibleEdgeColor.set('#ffffff');
                composer.addPass( outlinePass );
                composer.addPass( new AfterimagePass() );
                
                onWindowResize();
            }

            function animate() {
                setTimeout(() => {
                    requestAnimationFrame(animate);
                }, 1000 / 60);
                if (plane != null) {
                    plane.rotation.x = (plane.rotation.x*5 + planeXRot) / 6;
                    plane.rotation.y = (plane.rotation.y*5 + planeYRot) / 6;
                }
                if (ytEmbed != null) {
                    ytEmbed.rotation.x = (ytEmbed.rotation.x*5 + planeXRot) / 6;
                    ytEmbed.rotation.y = (ytEmbed.rotation.y*5 + planeYRot) / 6;
                }
                CSSrenderer.render(CSSscene, camera);
                composer.render(scene, camera);
            }

            function onWindowResize() {
                let width, height;
                if (window.visualViewport != undefined) {
                    width = window.visualViewport.width;
                    height = window.visualViewport.height;
                } else {
                    width = window.innerWidth;
                    height = window.innerHeight;
                }
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize( width, height );
                composer.setSize( width, height );
                CSSrenderer.setSize( width, height );
                // resize plane to fit in canvas
                if (plane != null) {
                    const vFOV = THREE.MathUtils.degToRad( camera.fov );
                    const visHeight = 2 * Math.tan( vFOV / 2 );
                    const visWidth = visHeight * camera.aspect;
                    plane.scale.set((width - 40) / width * visWidth, (height - 40) / height * visHeight, 1);
                }
                if (CSSrenderer != null) {
                    const vFOV = THREE.MathUtils.degToRad( camera.fov );
                    const visHeight = 2 * Math.tan( vFOV / 2 );
                    const visWidth = visHeight * camera.aspect;
                    if (visHeight > visWidth) {
                        // fit to 1/3rd width
                        const scale = visWidth / videoWidthPx / 3;
                        CSSscene.scale.set(scale, scale, scale);
                    } else {
                        // fit to 1/3rd height
                        const scale = visHeight / videoHeightPx / 3;
                        CSSscene.scale.set(scale, scale, scale);
                    }
                }
            }

            function onMouseMove(event) {
                const size = new THREE.Vector2();
                renderer.getSize(size);
                const width = size.x;
                const height = size.y;
                planeYRot = (event.clientX - width/2) / width / 50;
                planeXRot = (event.clientY - height/2) / height / 50;
            }


            init();
            animate();
        </script>
	</body>
</html>