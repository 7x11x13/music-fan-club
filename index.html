<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>official music fan club</title>
		<style>
			body { margin: 0; background-color: black; }
			canvas { display: block; }
            #ytplayer { pointer-events: none; }
            #thumbnail {
                box-shadow: 0 0 0px #ffffff;
                transition: 0.3s;
            }
            #thumbnail:hover {
                box-shadow: 0 0 5px #ffffff;
            }
            button {
                font-family: 'Courier New', monospace;
                background-color: black;
                color: white;
                font-size: 18px;
                outline: none;
                border-color: #ffffff;
                box-shadow: 0 0 5px #ffffff;
                transition: color 0.3s, background-color 0.3s;
            }
            button:hover {
                background-color: white;
                color: black;
                transition: color 0s, background-color 0s;
            }
            button:active {
                border-style: outset;
                background-color: black;
                color: white;
            }
            input[type=range] {
                margin: 11.7px 0;
                background-color: transparent;
                -webkit-appearance: none;
                transform-origin: center;
                transform:rotate(-90deg);
            }
            input[type=range]:focus {
                outline: none;
            }
            input[type=range]::-webkit-slider-runnable-track {
                background: #ffffff;
                border: 0.2px solid #ffffff;
                border-radius: 1.3px;
                width: 100%;
                height: 4.6px;
                cursor: pointer;
            }
            input[type=range]::-webkit-slider-thumb {
                margin-top: -11.7px;
                width: 6px;
                height: 28px;
                background: #000000;
                border: 3px solid #ffffff;
                cursor: pointer;
                -webkit-appearance: none;
            }
            input[type=range]:focus::-webkit-slider-runnable-track {
                background: #ffffff;
            }
            input[type=range]::-moz-range-track {
                background: #ffffff;
                border: 0.2px solid #ffffff;
                border-radius: 1.3px;
                width: 100%;
                height: 4.6px;
                cursor: pointer;
            }
            input[type=range]::-moz-range-thumb {
                width: 6px;
                height: 28px;
                background: #000000;
                border: 3px solid #ffffff;
                cursor: pointer;
            }
            input[type=range]::-ms-track {
                background: transparent;
                border-color: transparent;
                border-width: 11.7px 0;
                color: transparent;
                width: 100%;
                height: 4.6px;
                cursor: pointer;
            }
            input[type=range]::-ms-fill-lower {
                background: #ffffff;
                border: 0.2px solid #ffffff;
                border-radius: 2.6px;
            }
            input[type=range]::-ms-fill-upper {
                background: #ffffff;
                border: 0.2px solid #ffffff;
                border-radius: 2.6px;
            }
            input[type=range]::-ms-thumb {
                width: 6px;
                height: 28px;
                background: #000000;
                border: 3px solid #ffffff;
                cursor: pointer;
                margin-top: 0px;
                /*Needed to keep the Edge thumb centred*/
            }
            input[type=range]:focus::-ms-fill-lower {
                background: #ffffff;
            }
            input[type=range]:focus::-ms-fill-upper {
                background: #ffffff;
            }
            /*TODO: Use one of the selectors from https://stackoverflow.com/a/20541859/7077589 and figure out
            how to remove the virtical space around the range input in IE*/
            @supports (-ms-ime-align:auto) {
                /* Pre-Chromium Edge only styles, selector taken from hhttps://stackoverflow.com/a/32202953/7077589 */
                input[type=range] {
                    margin: 0;
                    /*Edge starts the margin from the thumb, not the track as other browsers do*/
                }
            }
		</style>
	</head>
	<body>
		<script type="module">
            import * as THREE from 'https://threejs.org/build/three.module.js';
            import { CSS3DRenderer, CSS3DObject } from 'https://threejs.org/examples/jsm/renderers/CSS3DRenderer.js';
            import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
            import { OutlinePass } from 'https://threejs.org/examples/jsm/postprocessing/OutlinePass.js';
            import { AfterimagePass } from 'https://threejs.org/examples/jsm/postprocessing/AfterimagePass.js';

            let plane;
            let CSSplane;
            let planeXRot = 0;
            let planeYRot = 0;
            let scene, CSSscene, camera, renderer, CSSrenderer, composer, ytplayer, ytEmbedObject;
            let stars = [];

            // constants
            const playlistID = 'UU1YTajqhUd01VO-yr5bL08A';
            const videoWidthPx = 480;
            const videoHeightPx = 360;
            const videoIDRegex = /[?&]v=([A-Za-z0-9_-]{11})/;

            window.addEventListener( 'resize', onWindowResize, false );
            window.addEventListener( 'mousemove', onMouseMove, false );

            function initStars() {

				// The loop will move from z position of -1000 to z position 1000, adding a random particle at each position. 
				for ( let z = -1000; z < 1000; z += 20 ) {
		
					// Make a sphere (exactly the same as before). 
					const geometry   = new THREE.SphereGeometry(0.5, 32, 32)
					const material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
					const sphere = new THREE.Mesh(geometry, material)
		
					// This time we give the sphere random x and y positions between -500 and 500
					sphere.position.x = Math.random() * 1000 - 500;
					sphere.position.y = Math.random() * 1000 - 500;
		
					// Then set the z position to where it is in the loop (distance of camera)
					sphere.position.z = z;
		
					// scale it up a bit
					sphere.scale.x = sphere.scale.y = 2;
		
					//add the sphere to the scene
					scene.add( sphere );
		
					//finally push it to the stars array 
					stars.push(sphere); 
				}
            }

            function animateStars() { 
                        
                // loop through each star
                for( let i=0; i<stars.length; i++ ) {
                    
                    const star = stars[i]; 
                        
                    // and move it forward dependent on the mouseY position. 
                    star.position.z +=  i/10;
                        
                    // if the particle is too close move it to the back
                    if(star.position.z>1000) star.position.z-=2000; 
                    
                }
            
            }

            function init() {

                scene = new THREE.Scene();
                CSSscene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set(0, 0, 1);

                renderer = new THREE.WebGLRenderer({alpha: true});
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.zIndex = -2;
                renderer.domElement.style.top = 0;
                
                CSSrenderer = new CSS3DRenderer();
                CSSrenderer.domElement.style.position = 'absolute';
                CSSrenderer.domElement.style.top = 0;
                CSSrenderer.domElement.appendChild(renderer.domElement);

                document.body.appendChild(CSSrenderer.domElement);
                
                // build scene
                const material = new THREE.MeshBasicMaterial( {opacity: 0, transparent: true} );
                plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
                scene.add( plane );
                
                // youtube embed
                const div = document.createElement( 'div' );
                div.style.width = `${videoWidthPx}px`;
                div.style.height = `${videoHeightPx}px`;
                div.style.backgroundColor = '#000';
                const iframe = document.createElement( 'iframe' );
                iframe.id = 'ytplayer';
                iframe.style.width = `${videoWidthPx}px`;
                iframe.style.height = `${videoHeightPx}px`;
                iframe.style.border = '0px';
                iframe.src = `https://www.youtube.com/embed/videoseries?list=${playlistID}&rel=0&controls=0&autoplay=1&enablejsapi=1&playsinline=1`;
                iframe.allow = 'accelerometer; autoplay; encrypted-media; gyroscope;';
                div.appendChild( iframe );
                ytEmbedObject = new CSS3DObject( div );
                ytEmbedObject.visible = false;

                // embed thumbnail (links to youtube page)
                const videoLink = document.createElement( 'a' );
                videoLink.id = 'videolink';
                const thumbnail = document.createElement( 'img' );
                thumbnail.id = 'thumbnail';
                thumbnail.style.width = `${videoWidthPx}px`;
                thumbnail.style.height = `${videoHeightPx}px`;
                videoLink.appendChild(thumbnail);
                ytEmbedObject.add(new CSS3DObject( videoLink ));

                // embed buttons
                const embedButtonWidth = (videoWidthPx - 60)/3;

                function createEmbedButton(text, onclick, x, y, z) {
                    const button = document.createElement( 'button' );
                    button.style.width = `${embedButtonWidth}px`;
                    button.innerText = text;
                    button.addEventListener('click', onclick);
                    const buttonObject = new CSS3DObject( button );
                    ytEmbedObject.add ( buttonObject );
                    buttonObject.position.set( x, y, z );
                    return button
                }

                // play/pause button
                const playButton = createEmbedButton(
                    'play',
                    function (event) {
                        if (event.target.innerText === 'play') {
                            ytplayer.playVideo();
                        } else {
                            ytplayer.pauseVideo();
                        }
                    }, 
                    -videoWidthPx/2 + embedButtonWidth/2, -videoHeightPx/2 - 20, 0
                );
                // prev video button
                createEmbedButton(
                    'prev',
                    function (event) {
                        ytplayer.previousVideo();
                    },
                    0, -videoHeightPx/2 - 20, 0
                );
                // next video button
                createEmbedButton(
                    'next',
                    function (event) {
                        ytplayer.nextVideo();
                    },
                    videoWidthPx/2 - embedButtonWidth/2, -videoHeightPx/2 - 20, 0
                );
                // volume slider
                const sliderDiv = document.createElement( 'div' );
                const slider = document.createElement( 'input' )
                slider.style.width = `${videoHeightPx*3/4}px`;
                slider.style.height = '20px';
                slider.type = 'range';
                slider.id = 'volume';
                slider.min = '0';
                slider.max = '100';
                slider.value = '100';
                slider.addEventListener('input', function(event) {
                    ytplayer.setVolume(event.target.valueAsNumber);
                });
                sliderDiv.appendChild( slider );
                const sliderObject = new CSS3DObject( sliderDiv );
                ytEmbedObject.add ( sliderObject );
                sliderObject.position.set( -videoWidthPx/2 - 20, 0, 0 );

                CSSplane = new THREE.Group();
                CSSplane.add( ytEmbedObject );

                window.onPlayerStateChange = function (event) {
                    if (event.data === YT.PlayerState.PLAYING) {
                        playButton.innerText = 'pause';
                        const url = ytplayer.getVideoUrl();
                        const link = document.getElementById('videolink');
                        const image = document.getElementById('thumbnail');
                        link.href = url;
                        link.target = '_blank';
                        const id = videoIDRegex.exec(url)[1];
                        image.src = `https://img.youtube.com/vi/${id}/sddefault.jpg`
                        image.style.opacity = 1;
                    } else if (event.data === YT.PlayerState.PAUSED) {
                        playButton.innerText = 'play';
                        const image = document.getElementById('thumbnail');
                        image.style.opacity = 0.5;
                    }
                }
                window.onYouTubeIframeAPIReady = function () {
                    ytplayer = new YT.Player('ytplayer', {
                        events: {
                            'onStateChange': onPlayerStateChange
                        }
                    });
                };

                CSSscene.add( CSSplane );

                // load iframe API
                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                
                // postprocessing effects
                composer = new EffectComposer( renderer );
                composer.addPass( new RenderPass( scene, camera ) );
                const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera, [plane]);
                outlinePass.edgeStrength = 8;
                outlinePass.visibleEdgeColor.set('#ffffff');
                composer.addPass( outlinePass );
                composer.addPass( new AfterimagePass() );
                
                initStars();

                onWindowResize();
            }

            function animate() {
                setTimeout(() => {
                    requestAnimationFrame(animate);
                }, 1000 / 60);
                if (plane != null) {
                    plane.rotation.x = (plane.rotation.x*5 + planeXRot) / 6;
                    plane.rotation.y = (plane.rotation.y*5 + planeYRot) / 6;
                }
                if (CSSplane != null) {
                    CSSplane.rotation.x = (CSSplane.rotation.x*5 + planeXRot) / 6;
                    CSSplane.rotation.y = (CSSplane.rotation.y*5 + planeYRot) / 6;
                }
                animateStars();
                CSSrenderer.render(CSSscene, camera);
                composer.render(scene, camera);
            }

            function onWindowResize() {
                let width, height;
                if (window.visualViewport != undefined) {
                    width = window.visualViewport.width;
                    height = window.visualViewport.height;
                } else {
                    width = window.innerWidth;
                    height = window.innerHeight;
                }
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize( width, height );
                composer.setSize( width, height );
                CSSrenderer.setSize( width, height );
                // resize plane to fit in canvas
                if (plane != null) {
                    const vFOV = THREE.MathUtils.degToRad( camera.fov );
                    const visHeight = 2 * Math.tan( vFOV / 2 );
                    const visWidth = visHeight * camera.aspect;
                    plane.scale.set((width - 40) / width * visWidth, (height - 40) / height * visHeight, 1);
                }
                if (CSSrenderer != null) {
                    const vFOV = THREE.MathUtils.degToRad( camera.fov );
                    const visHeight = 2 * Math.tan( vFOV / 2 );
                    const visWidth = visHeight * camera.aspect;
                    let scale;
                    if (visHeight > visWidth) {
                        // fit to 1/3rd width
                        scale = visWidth / videoWidthPx / 3;
                    } else {
                        // fit to 1/3rd height
                        scale = visHeight / videoHeightPx / 3;
                    }
                    CSSscene.scale.set( scale, scale, scale );
                    // move yt embed to 3/4ths the way up the screen
                    if (ytEmbedObject != null) {
                        ytEmbedObject.position.set( 0, visHeight / scale / 4, 0 );
                    }
                }
            }

            function onMouseMove(event) {
                const size = new THREE.Vector2();
                renderer.getSize(size);
                const width = size.x;
                const height = size.y;
                planeYRot = (event.clientX - width/2) / width / 50;
                planeXRot = (event.clientY - height/2) / height / 50;
            }


            init();
            animate();
        </script>
	</body>
</html>