<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>official music fan club</title>
		<style>
			body { margin: 0; background-color: black}
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script type="module">
            import * as THREE from 'https://cdn.skypack.dev/three@0.132.2/build/three.module.js';
            import { CSS3DRenderer, CSS3DObject } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/renderers/CSS3DRenderer.js';
            import { EffectComposer } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/RenderPass.js';
            import { OutlinePass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/OutlinePass.js';
            import { AfterimagePass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/AfterimagePass.js';

            let plane = null;
            let planeXRot = 0;
            let planeYRot = 0;
            let ytEmbed = null;
            let scene, CSSscene, camera, renderer, CSSrenderer, composer;

            window.addEventListener( 'resize', onWindowResize, false );
            window.addEventListener( 'mousemove', onMouseMove, false );

            async function init() {
                scene = new THREE.Scene();
                CSSscene = new THREE.Scene();
                CSSscene.scale.set(0.005, 0.005, 0.005);

                camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set(0, 0, 1);

                renderer = new THREE.WebGLRenderer({alpha: true});
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.domElement.style.position = 'absolute';
                renderer.domElement.style.zIndex = -2;
                renderer.domElement.style.top = 0;
                
                CSSrenderer = new CSS3DRenderer();
                CSSrenderer.domElement.style.position = 'absolute';
                CSSrenderer.domElement.style.top = 0;
                CSSrenderer.domElement.appendChild(renderer.domElement);

                document.body.appendChild(CSSrenderer.domElement);

                composer = new EffectComposer( renderer );
                composer.addPass( new RenderPass( scene, camera ) );
                
                // build scene
                const geometry = new THREE.PlaneGeometry( 1, 1 );
                const material = new THREE.MeshBasicMaterial( {color: 0x000000, side: THREE.DoubleSide} );
                plane = new THREE.Mesh( geometry, material );
                scene.add( plane );
                
                // youtube embed
                const id = 'Xxg9gmnzEDo';
                const div = document.createElement( 'div' );
                div.style.width = '480px';
                div.style.height = '360px';
                div.style.backgroundColor = '#000';
                const iframe = document.createElement( 'iframe' );
                iframe.style.width = '480px';
                iframe.style.height = '360px';
                iframe.style.border = '0px';
                iframe.src = [ 'https://www.youtube.com/embed/', id, '?rel=0&controls=0&showinfo=0&autoplay=1' ].join( '' );
                iframe.allow = 'accelerometer; autoplay; encrypted-media; gyroscope;';
                div.appendChild( iframe );
                ytEmbed = new CSS3DObject( div );
                ytEmbed.position.set(0, 0, 0);
                CSSscene.add( ytEmbed );
                
                // postprocessing effects
                const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera, [plane]);
                outlinePass.edgeStrength = 8;
                outlinePass.visibleEdgeColor.set('#ffffff');
                composer.addPass( outlinePass );
                composer.addPass( new AfterimagePass() );
                
                onWindowResize();
            }

            function animate() {
                setTimeout(() => {
                    requestAnimationFrame(animate);
                }, 1000 / 60);
                if (plane != null) {
                    plane.rotation.x = (plane.rotation.x*5 + planeXRot) / 6;
                    plane.rotation.y = (plane.rotation.y*5 + planeYRot) / 6;
                }
                if (ytEmbed != null) {
                    ytEmbed.rotation.x = (ytEmbed.rotation.x*5 + planeXRot) / 6;
                    ytEmbed.rotation.y = (ytEmbed.rotation.y*5 + planeYRot) / 6;
                }
                CSSrenderer.render(CSSscene, camera);
                composer.render(scene, camera);
            }

            function onWindowResize() {
                let width, height;
                if (window.visualViewport != undefined) {
                    width = window.visualViewport.width;
                    height = window.visualViewport.height;
                } else {
                    width = window.innerWidth;
                    height = window.innerHeight;
                }
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize( width, height );
                composer.setSize( width, height );
                CSSrenderer.setSize( width, height );
                // resize plane to fit in canvas
                if (plane != null) {
                    const vFOV = THREE.MathUtils.degToRad( camera.fov );
                    const visHeight = 2 * Math.tan( vFOV / 2 );
                    const visWidth = visHeight * camera.aspect;
                    plane.scale.set((width - 40) / width * visWidth, (height - 40) / height * visHeight, 1);
                }
            }

            function onMouseMove(event) {
                const size = new THREE.Vector2();
                renderer.getSize(size);
                const width = size.x;
                const height = size.y;
                planeYRot = (event.clientX - width/2) / width / 50;
                planeXRot = (event.clientY - height/2) / height / 50;
            }


            init();
            animate();
        </script>
	</body>
</html>